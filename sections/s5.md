## 5. Building a MVRC (minimal viable rootless container)

> **Note**: This demonstration linux kernel specific. I will share the slides and github link at the end of the
> presentation if anyone would like to try it themselves. Remember, though, you'll need to be on a linux machine, linux vm, use wsl2, or in container with special privileges.

Also, If you Liz Rice has multiple videos on youtube of her building containers from scratch in Go. She's an incredible speaker and author - who literally wrote the book on [Container security"](https://containersecurity.tech/). Many portions of this section are inspired by Liz

Alright, it's time to start coding ourselves a MVRC. We'll be focusing more today on using namespaces to get process isolation and will save cgroups for later.

Similar to:

`docker run <options> <image> <command> <args>`

`cargo run -- <command> <args>`

## Coding

### Explain Learning Outcome:

- By the end of this section, you'll be able to create a minimal rootless container in Rust using primarily the nix crate.

### Show project starting point

- Cargo.toml with nix stuff

"Here's our starting point"

### Data Tracking

Before we begin, we're going to need to have a sort of data checker using this print function

```rust
    eprintln!(
        "euid [{}] pid [{}] hostname [{:?}] cwd [{:?}]",
        geteuid(),
        getpid(),
        getcwd().expect("Failed to get the cwd.")
    );
```

Alright, everything checks out. Now, let's build our mini-cli. Normally, I would use clap, but for this quick demo, we are going to collect the cmd and args.

### CLI

```rust
    use std::env;
    let args: Vec<String> = env::args().collect();
    if args.len() < 2 {
        panic!("Usage: <cmd> [args...]\nExample: ls -la");
    }
    dbg!(&args);
```

```shell
    cargo run -- hello seattle
```

### Execvp

exec family of sys calls. They replace the current process with a copy of the last one
"Replace the current process image with a new one and replicate shell PATH searching behavior" - nix or man?

```rust
    use std::{env, ffi::CString};

    use nix::unistd::execvp;

        let args: Vec<String> = env::args().collect();
    if args.len() < 2 {
        panic!("Usage: <cmd> [args...]\nExample: ls -la");
    }

    let cmd = &args[1];
    let argv: Vec<CString> = args[1..]
        .iter()
        .map(|s| CString::new(s.as_str()).expect("Not a valid CString: argv"))
        .collect();
    execvp(
        &CString::new(cmd.to_owned()).expect("Not a valid CString: cmd"),
        &argv,
    )
    .expect("Failed to replace current process image [exec]");
```

[Remember, no sudo yet!!!]

```bash
    cargo run -- echo hello seattle
```

We haven't don't anything "container-y" just yet. So let's open a shell and see what's available to us in the process.

```bash
    cargo run -- sh
    $ id
    $ echo $$
    $ hostname
    $ pwd
```

So now that we've gotten some information about this process, let's try and do something within the shell.

```bash
    $ hostname my-container
    hostname: you must be root to change the host name
```

To change the hostname, I will need to use `sudo`, however, doing this will change the hostname on my machine. To actually isolate this process, and to fist give it something consistent to a container, we'll need to use namespaces. A quick refresher:

### Container basics (namespaces and syscalls)

**namespaces** allow or this illusion isolation

### Contents of a process:

/proc/<pid> and /proc/<pid>/ns
"Every process has namespaces"

[example] make a process sleep, then in another terminal run ps -eaf | grep sleep, find tht pid, then ls /proc/<pid>/ns and show the namespaces available to the process

/proc is a pseudo-filesystem that exposes kernel data structures - we'll use it to see our process's namespaces.

- namespaces restrict and limit what the process can see [!!!LIZRICE!!!]
  set using kernel syscalls. Again, I will not be doing cgroups in todays talk as that is for a whole different talk.

"Let me step back and explain what namespaces are available to us".

namespaces:

- cgroup
- ipc - "isolate between different IPC resources like message queues, semaphores and shared memory." - Shlomi Boutnaru, Ph.D
- mnt - mounts seen by the process
- net - isolation of networking system resources
- pid - isolates the process id
- time
- user - user and group ids isolation (for rootless)
- uts - isolates hostname of process

### Syscalls

We can cause affect to the process namespaces using syscalls (system calls) which are APIs provided by the Linux Kernel
syscalls:

- unshare(): "allow a process to control its shared execution context" - unshare(2)
- mount/umount(): attaches or detaches a filesystem
- execv - replaces current process image with another (not a new process)
- fork():
  "creates a new process by duplicating the calling process.
  The new process is referred to as the child process. The calling
  process is referred to as the parent process." - fork(2)
- chroot(): Changes the processes root directory of the process

### uts ns

Ok, so to isolate the process' uts namespace we'll `unshare` the uts namespace.

```rust
    unshare(CloneFlags::CLONE_NEWUTS).expect("Failed to create uts namespace");
```

```bash
    cargo run -- sh
    thread 'main' (7053) panicked at src/main.rs:38:39:
    Failed to create uts namespace: EPERM
```

And we don't have permission as anticipated. We will need to use `sudo` or go rootless. Just to demonstrate I'll use root to demonstrate the container.

```shell
    cargo build
    sudo ./target/debug/hello-container

    euid [0] pid [7338] hostname ["End-of-the-World"] cwd ["/home/cquick/dev/hello-container"]
    # hostname new-container
    # hostname
    new-container
```

In a separate terminal, we see that the hostname on the machine hasn't changed. Yaaay! We have kind of a container. It's not fancy but the process shows signs of isolation.

```shell
    cquick@End-of-the-World:~/dev/hello-container$ hostname
    End-of-the-World
```

<!-- [note]
$ (Dollar Sign): This is the default prompt for a standard, unprivileged user. It signifies that you are operating with normal user permissions.

# (Hash Sign / Pound Sign): This is the default prompt for the root user. It signifies that you are operating with administrative or superuser privileges, granting you full control over the system.

Remember, though, that we ran this process as root, and this is not good. -->

```shell
    # whoami
    root
    # sleep 1000
```

OTHER TERMINAL

```bash
    cquick@End-of-the-World:~/dev/hello-container$ ps aux | grep sleep
    root        7546  0.0  0.1  14424  6392 pts/2    S+   10:58   0:00 sleep 1000
```

Before we move on, let's make this container rootless.

### Rootless

#### user ns

Before we move ahead let's make this container looking process rootless.

Now we're going to modify our second namespace for the process, the user namespace. Our intention is to make this process its own root that isn't dependent on the host root.

Essentially, we are going to disassociate the current process' user. By doing this we'll have an empty uid and gid mapping, that we'll need to fill out the make the process its own root.

<!-- When we unshare the user namespace, the process enters a new namespace with no users defined - it's a blank slate. The process has no identity yet.
We need to tell Linux: "uid 0 inside this namespace maps to my actual uid on the host." That's what the uid_map file does. The format is: <inside_uid> <outside_uid> <count>.
So 0 1000 1 means: uid 0 inside maps to uid 1000 outside, for 1 user.
Result: inside the container, we're root. On the host, we're still just our regular unprivileged user. -->

```rust
    // ** Go Rootless **//
    let host_uid = nix::unistd::getuid();
    let host_gid = nix::unistd::getgid();
    let uid_map = format!("0 {} 1", host_uid);
    let gid_map = format!("0 {} 1", host_gid);
    unshare(CloneFlags::CLONE_NEWUSER).expect("Failed to create user namespace");
    std::fs::write("/proc/self/uid_map", uid_map).expect("Failed to write to uid");
    let setgroups_path = PathBuf::from("/proc").join("self").join("setgroups");
    std::fs::write(setgroups_path, "deny").expect("Failed to write to gid setgroup");
    std::fs::write("/proc/self/gid_map", gid_map).expect("Failed to write to gid");
```

Now we can use `cargo run -- sh` without granting sudo to the process. As mentioned earlier, this is not for convenience sake, but also vital to container security.

```shell
    euid [0] pid [7895] cwd ["/home/cquick/dev/hello-container"]
```

Also, notice that the effective uid is 0 meaning root and we didn't need to use the host's sudo.

Running sleep again, we see `cquick      8047  0.0  0.1  14428  6396 pts/0    S+   11:06   0:00 sleep 1000` in a different terminal. The container is running as a unprivileged process, but as its own root. To the host machine, it is simply another process.

Let's keep building this container, it's finally taking shape!

### pid ns

Given a new process id namespace disallows the process from seeing the processes from outside the current process.

```rust
unshare(CloneFlags::CLONE_NEWPID).expect("Failed to create a PID namespace");
```

Nothing changes. This new pid namespace sets up the child process to get pid 1.

```text
    "The first process created in a new namespace (i.e., the process
    created using clone(2) with the CLONE_NEWPID flag, or the first
    child created by a process after a call to unshare(2) using the
    CLONE_NEWPID flag) has the PID 1"
    - https://man7.org/linux/man-pages/man7/pid_namespaces.7.html
```

To do this, we need to fork the process and create a child.

#### fork()

```text
    "fork() creates a new process by duplicating the calling process.
    The new process is referred to as the child process.  The calling
    process is referred to as the parent process."
    - https://man7.org/linux/man-pages/man2/fork.2.html
```

In this example, we are going to fork the process leaving the parent to wait for a signal from the child using waitpid, and the fork result of the child will be our future container.

Run it - PID is 1!

> [Disclaimer]
> single threaded for today's example. Using anything that can unravel the process' stack and leave other threads
> abandoned is not good. However, for today's example I am single thread and for the sake of time will use use expect
> and other functions that shouldnt be in production. The github repo with this example WILL have proper error handling.

```rust
    match unsafe { fork() } {
        Ok(ForkResult::Parent { child, .. }) => {
            waitpid(child, None)
                .expect("Something went wrong waiting for the child's signal to change.");
        }
        Ok(ForkResult::Child) => {
            get_proc_info();
            execvp(
                &CString::new(cmd.to_owned()).expect("Not a valid CString: cmd"),
                &argv,
            )
            .expect("Failed to replace current process image [exec]");
        }
        Err(_) => eprintln!("Fork failed"),
    }
```

[The code up until this point]

```rust
use std::{env, ffi::CString, path::PathBuf};

use nix::{
    sched::{CloneFlags, unshare},
    sys::wait::waitpid,
    unistd::{ForkResult, execvp, fork, getcwd, geteuid, getpid},
};

fn get_proc_info() {
    eprintln!(
        "euid [{}] pid [{}] cwd [{:?}]",
        geteuid(),
        getpid(),
        getcwd().expect("Failed to get the cwd.")
    );
}

fn main() {
    //** Collect Command and Args **/
    let args: Vec<String> = env::args().collect();
    if args.len() < 2 {
        panic!("Usage: <cmd> [args...]\nExample: ls -la");
    }

    // ** Go Rootless **//
    let host_uid = nix::unistd::getuid();
    let host_gid = nix::unistd::getgid();
    let uid_map = format!("0 {} 1", host_uid);
    let gid_map = format!("0 {} 1", host_gid);
    unshare(CloneFlags::CLONE_NEWUSER).expect("Failed to create user namespace");
    std::fs::write("/proc/self/uid_map", uid_map).expect("Failed to write to uid");
    let setgroups_path = PathBuf::from("/proc").join("self").join("setgroups");
    std::fs::write(setgroups_path, "deny").expect("Failed to write to gid setgroup");
    std::fs::write("/proc/self/gid_map", gid_map).expect("Failed to write to gid");

    unshare(CloneFlags::CLONE_NEWUTS).expect("Failed to create uts namespace");

    let cmd = &args[1];
    let argv: Vec<CString> = args[1..]
        .iter()
        .map(|s| CString::new(s.as_str()).expect("Not a valid CString: argv"))
        .collect();

    unshare(CloneFlags::CLONE_NEWPID).expect("Failed to create a PID namespace");

    match unsafe { fork() } {
        Ok(ForkResult::Parent { child, .. }) => {
            waitpid(child, None)
                .expect("Something went wrong waiting for the child's signal to change.");
        }
        Ok(ForkResult::Child) => {
            get_proc_info();
            execvp(
                &CString::new(cmd.to_owned()).expect("Not a valid CString: cmd"),
                &argv,
            )
            .expect("Failed to replace current process image [exec]");
        }
        Err(e) => {
            eprintln!("Fork failed: {}", e);
            process::exit(1);
        }
    }
}
```

### Rootfs

So far, our container is rootless and thinks it's alone using the linux kernel. It doesnt seem too fancy, and we are missing a core component: rootfs.

Right now, the container still has access to the parent's filesystem: my machine's /bin/sh or /bin/ls. When you pull an image from docker hub, for example, you are essentially pulling a bunch of manifests with details on image layers and their mounting order. With this, you are actually pulling a root filesystem for the container. Meaning, you are actually getting gzipped root linux filesystems to work with.

For today's demonstration, I've pulled, and untarred a busybox image to use. Your container runtimes will handle the reading of the manifests and build the container accordingly. For today, I am using a simple, single layered busybox.

```shell
    docker save -o ~/talks/busybox.tar busybox:latest
```

navigate to the folder where you have the image and it's fs. Show the fs using `ls`.

Since we aren't building a container with an overlayfs (readable and writable image layers), we are simply going to mount the busybox image's fs and go to town.

#### mnt ns

```rust
    let rootfs = PathBuf::from("/home/cquick/talks/rootfs");
    let container_dir = PathBuf::from("/home/cquick/talks/container");

    // -- snip --
        //** Create mount namespace (isolates your filesystem operations) **//
    unshare(CloneFlags::CLONE_NEWNS).expect("Failed to create a mounted namespace");
    //** Create your container root directory **//
    if !Path::new(&container_dir).exists() {
        fs::create_dir_all(&container_dir).expect("Failed to create path");
    }
    //** Mount/copy your container filesystem into that directory **//
    let source_dir = &rootfs;
    let source = Some(source_dir);
    let target = &container_dir;
    let fstype = None::<&str>;
    let flags = MsFlags::MS_BIND;
    let data = None::<&str>;
    mount(source, target, fstype, flags, data).expect("Failed to Mount Filesystem");

    // in the Ok(ForkResult::Child) => {
        chroot(&container_dir).expect("chroot failed");
        std::env::set_current_dir("/").expect("Couldn't change current working directory.");
    // }
```

We'll bind mount the pulled rootfs, mount it.

Even though we've added the mount ns and mounted the fs, we still need to tell the container where the new root filesystem is located. We'll use the syscall `chroot()` or change root, then tell the container where it's new cwd will be and in this case we'll make it root `/`.

There are more aspects of the process we can isolate, but here we have a MVRC - miniaml viable rootless container.

Resources:
- https://www.lizrice.com/
- https://containersecurity.tech/
- https://www.youtube.com/watch?v=jeTKgAEyhsA

- https://docs.docker.com/reference/cli/docker/container/run/

- https://man7.org/linux/man-pages/man7/namespaces.7.html
- https://man7.org/linux/man-pages/man7/cgroups.7.html

- https://man7.org/linux/man-pages/man2/unshare.2.html
- https://man7.org/linux/man-pages/man2/umount.2.html
- https://man7.org/linux/man-pages/man8/mount.8.html
- https://man7.org/linux/man-pages/man2/execve.2.html
- https://man7.org/linux/man-pages/man2/fork.2.html
- https://man7.org/linux/man-pages/man2/chroot.2.html