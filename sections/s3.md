## 3. Rootless Containers

So far, we’ve said that a container is just a process with a restricted view of the system.

That raises an important question:
what privileges does that process actually have?

By default, most container runtimes run containers as root.
And that’s not “container root” — that’s real root on the host.

The isolation comes from namespaces, not from reduced privileges.

That means if a process escapes its namespace isolation, it escapes as root — which is obviously not ideal.

Rootless containers flip that model around.
Instead of starting with maximum privilege and trying to contain it, they start as an unprivileged user and selectively add isolation.

This dramatically reduces the blast radius of bugs or misconfigurations — and it’s why rootless containers matter from a security perspective.

Before we build anything ourselves, let’s look at what this means in practice.

[ Pre-recorded GIF/static image on the slide ]

```bash
docker run -it --name busybox-container busybox /bin/sh
    #/ whoami
    #/ sleep 1000
```

in a different terminal window

```bash
ps -aux | grep sleep
```

> Run docker container, sleep 1000, then in another terminal ps -eaf | grep sleep and show it's as root (not container root). Mention you can run docker and podman containers rootless, but aren't by default.

Notice that this process is running as root on the host.
That’s not container root — that’s real root.

You can run Docker or Podman rootless today — but it’s not the default.
So instead of relying on tooling, we’re going to build the core idea ourselves.