## 4. Why Rust + The Tools We'll Use
## 4. Why Rust + The Tools We'll Use

When you’re building containers, you’re crossing security boundaries constantly.
You’re talking directly to the kernel — and mistakes don’t just crash programs, they break isolation.

Rust doesn’t invent new container primitives.
It doesn’t replace Linux syscalls.

What it does give you is compiler-enforced honesty.

Every fallible operation returns a Result.
Every unsafe operation is explicitly marked.
Every boundary between “safe” and “dangerous” is visible in the code.

That makes Rust unusually good for understanding container internals — because the language refuses to let you gloss over the hard parts.

I started this project while learning Rust, and I quickly realized that this wasn’t just about safety — it was about clarity.
Rust forced me to acknowledge every failure case, every privilege boundary, and every place I was asking the kernel to do something risky.

To actually call Linux system calls from Rust, we’ll use the nix crate.
Nix wraps low-level libc calls in safe, idiomatic Rust APIs — not by hiding danger, but by making it explicit in the type system.

For example, compare calling gethostname through libc versus through nix.

```rust
// libc api (unsafe, requires handling return code/errno)
pub unsafe extern fn gethostname(name: *mut c_char, len: size_t) -> c_int;

// nix api (returns a nix::Result<OsString>)
pub fn gethostname() -> Result<OsString>;
```
[nix/README.md](https://github.com/nix-rust/nix/blob/master/README.md)

Rust hasn’t made this syscall safer — the kernel is still the kernel.
But it has made the boundary visible: this can fail, and you must handle it.

With that framing in place, let’s start building a minimal container and see how these boundaries show up in practice.

