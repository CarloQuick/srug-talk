## 4. Why Rust + The Tools We'll Use

I had just started my Rust journey when I started getting interested in containers. I was looking for a project while going through the Rust book, so I happened into this project using Rust instead of C or Go. Once I decided to use Rust and researched other Rust container runtimes, youki in particular, I was glad I made the choice.

I understood the project was going to be quite complicated so I thought no better reason than to facilitate this perceived complexity with the safety that Rust offers.

There was the learning curve of course, but using Rust forced me to think deeply before implementation. Even though I struggled with error handling, I was glad it was there. The Rust compiler forced me to handle errors, the borrow checker enforced memory safety - things I would have ignored in other languages. Frustrating at first, but exactly what you want when you're messing with system calls.

There are many great container tools written in other languages. However, there are trade offs that make Rust a strong candidate for the future of containerization. Syscalls can be trickier to use in Go vs Rust, and Rust provides memory safety over C implementations. [Youki]

So how do we actually call Linux syscalls from Rust? Enter my bff crate: nix.

### nix crate

We'll be using nix for unshare, mount, chroot, and other syscalls throughout the build.

"Nix provides a safe alternative to the unsafe APIs exposed by the libc crate. This is done by wrapping the libc functionality with types/abstractions that enforce legal/safe usage."

```rust
// libc api (unsafe, requires handling return code/errno)
pub unsafe extern fn gethostname(name: *mut c_char, len: size_t) -> c_int;

// nix api (returns a nix::Result<OsString>)
pub fn gethostname() -> Result<OsString>;
```

Enough talk, let's build!

### Resources:
https://docs.rs/crate/nix/latest
